	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/My_usrname_of_choice" target="_blank">My_usrname_of_choice</a>
			<div class="markdown"><p>Every time I read assembly mentioned I think of the fact that the game Rollercoaster Tycoon was originally written in 99% assembly code. That's fucking crazy.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ThrowawayusGenerica" target="_blank">ThrowawayusGenerica</a>
			<div class="markdown"><p>It was still weirdly common to code PC games in assembly in the late 90s. Age of Empires was done in assembly too.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/eldelshell" target="_blank">eldelshell</a>
			<div class="markdown"><p>NES games were all Assembly AFAIK, SMB for example.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/gumenski" target="_blank">gumenski</a>
			<div class="markdown"><p>No it wasn't.  Certain parts were coded with inline assembler.</p>
<p>AoE heavily abused C++, and like many other programs it used inline assembler only where it made sense.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/avael273" target="_blank">avael273</a>
			<div class="markdown"><p>It is mostly due to huge increase in both memory capacity and processing power that we mostly do not write in assembly, for micro-controllers and embedded device assembly is still quite common, not x86 assembly though.</p>
<p>What made it possible is use of technologies such as abstract syntax trees and other optimizations which require memory and quite a bit of processing power to do. </p>
<p>As a programmer you write code in phases, mostly you write some code, you check it, you debug it, then on to next feature. If you make compile stage last hours it makes work less efficient. </p>
<p>We had that, before assembly, with mainframes and punch cards where you would give your cards to technicians when it has free slot, to load code into machine and print results on paper then go through it, and if you made a mistake or machine threw and error you do whole stack of punch cards from scratch.</p>
<p>TL;DR It was just faster to write assembly yourself as compilers were bad at optimizing it at the time.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/jaredearle" target="_blank">jaredearle</a>
			<div class="markdown"><p>Lots of games and other software in the 80s were written in assembly. There was a very popular package called Devpac on the Atari ST and Amiga we all used. It wasn’t anywhere near as rare as you’d think. </p>
<p>I seem to remember Peter Molyneux wrote a monthly course on how to write games in Assembly in one of the ST magazines.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/antiquemule" target="_blank">antiquemule</a>
			<div class="markdown"><p><em>Sheds a nostalgic tear.</em> </p>
<p>Did you read &quot;<em>Byte&quot;</em> magazine too?</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/[deleted]" target="_blank">[deleted]</a>
			<div class="markdown"><p>[gelöscht]</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/flexylol" target="_blank">flexylol</a>
			<div class="markdown"><p>&quot;Devpac&quot; doesn't ring a bell at all  to me, but I did assembly programming on Amiga. I remember the Seka assembler (K-Seka?) and (now googling) &quot;Asm One&quot;. I remember I felt like the biggest Guru writing some simple demos in assembler :)</p>
<p>What was (and to me, still is!) the &quot;best&quot; programming language? GFA Basic was absolutely effing amazing. It was interpreted but you could also also compile it, and it was super fast. You could even write games with Gfa basic.</p>
<p>Some guy at a later time also created an excellent language called &quot;E&quot;</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/nerdvegas79" target="_blank">nerdvegas79</a>
			<div class="markdown"><p>I used to be a PS2 graphics programmer. It had these things called Vector Units, and you had to program then in their own assembly. It executed two streams of different code at the same time - one int, one float. You had to know the latency of each instruction, for eg a vector float divide might be readable two instructions later. You had 32 int registers and 16 float iirc. I wrote a terrain renderer with it and probably almost lost my mind. This was about 17 years ago now.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/postreplypreview" target="_blank">postreplypreview</a>
			<div class="markdown"><p>Poor bastard. Console development is the worst.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/XrosRoadKiller" target="_blank">XrosRoadKiller</a>
			<div class="markdown"><p>Thank you for your service.</p>
<p>...Unless You worked on Brave Fencer Musashi 2 because then you deserved it.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Randomly_Redditing" target="_blank">Randomly_Redditing</a>
			<div class="markdown"><p>Thank you it was very helpful</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mfanter" target="_blank">mfanter</a>
			<div class="markdown"><p>OP,  check out nand2tetris - it’s a course developed specifically to show the transition from 1s and 0s to memory, CPU, and eventually an assembly-like language - the ultimate end is a Tetris game run on the machine you virtually built from scratch.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/FunnySheep" target="_blank">FunnySheep</a>
			<div class="markdown"><p>Nand2tetris should be part of every cs course.<br />
awesome way of learning about how computers and software  work.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ImRox" target="_blank">ImRox</a>
			<div class="markdown"><p>!remindme 3 years</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Wisebeuy" target="_blank">Wisebeuy</a>
			<div class="markdown"><p>Another great find, this along with ben eaters videos provide a very clear understanding of how computers work.</p>
<p>If you know of any other similar video series please let me know!</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/dochalladay32" target="_blank">dochalladay32</a>
			<div class="markdown"><p>Consider watching BenEater on YouTube. His 6502 computer build starts out writing hello world in machine code before moving to assembly so you can see exactly how it goes from 1's and 0's to assembly.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/wibblewafs" target="_blank">wibblewafs</a>
			<div class="markdown"><p>You can't go wrong with a guide on how computers work that starts by pulling out a breadboard and chucking a CPU onto it.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/rzrules" target="_blank">rzrules</a>
			<div class="markdown"><p>Highly recommend the 20 something minuted episode about coding on the documentart series - Vox Explained (on Netflix). They've done a great job!</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/rancor3000" target="_blank">rancor3000</a>
			<div class="markdown"><p>Came here to say this. It was so well explained!</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/peridotdragon33" target="_blank">peridotdragon33</a>
			<div class="markdown"><p>!remindme 10 hours</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/marr" target="_blank">marr</a>
			<div class="markdown"><p>And the first operating systems used to enable keyboard drivers to input the first assemblers were written on paper and entered by flipping banks of toggle switches and pulling the 'next register' lever.  <a href="https://en.wikipedia.org/wiki/Altair_8800" target="_blank">https://en.wikipedia.org/wiki/Altair_8800</a></p>
<p>When you power up a modern computer it goes through a high speed replay of this process known as bootstrapping, but the first bootstraps were tied by hand.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/RedPetrichor" target="_blank">RedPetrichor</a>
			<div class="markdown"><p>We've come a long way</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/hullabaloonatic" target="_blank">hullabaloonatic</a>
			<div class="markdown"><p>Computer science has this concept called &quot;black boxing&quot; where you take a reliable function and you just completely disregard how it works. I don't care how it works anymore, it just does, so I'm just gonna use it.</p>
<p>With that philosophy, modern computers (and networks) are just layers and layers of hacks.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/marr" target="_blank">marr</a>
			<div class="markdown"><p>And yet all modern systems are still built on that same Jenga tower of fundamental building blocks running at ever more absurd clock speeds.  It seems ridiculous that any of this stuff still works with so many interdependent layers stacked up.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SequoiaBalls" target="_blank">SequoiaBalls</a>
			<div class="markdown"><p>Sure would be a shame if....</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ClamClone" target="_blank">ClamClone</a>
			<div class="markdown"><p>My first job used TEMPO II minicomputers. They had two round tape drives, and were booted with paper tape on a teletype. The operators used the front paddle switches to start them up. At one point I observed that about four of the steps they used to boot didn't do anything. It was just load the program counter to the start routine and GO. Often as the memory was core memory they didn't even need booted, it was already there.</p></div>		</li>
					</ul>
		</ul>
	