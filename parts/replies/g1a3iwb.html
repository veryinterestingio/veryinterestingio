	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/25c-nb" target="_blank">25c-nb</a>
			<div class="markdown"><p>This is much more along the lines of whati was hoping for in an answer. The way the circuits in a PC (which I've built a few of, so I've always marveled at this) are able to use simple 1s and 0s to create the huge array of different things we use them for, from 3D graphics to insane calculations to image and video compiling.. thanks so much for getting me that much closer to understanding! I get the hardware its the hardware/software interaction that remains mysterious. </p>
<p>What I still don't really get is how you can code a string of &quot;words&quot; from a programming syntax (sorry if I'm butchering the nomenclature) into a program, run it, and the computer does extremely specific and complex things that result in all of the cool things we use computers for. How does it go from code (a type of language of you will) to binary (simple ones and zeros!) to a complex 3D graphical output?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/xoxorockoutloud123" target="_blank">xoxorockoutloud123</a>
			<div class="markdown"><p>I can answer this one. It's mostly down to &quot;levels of abstraction.&quot; As you mentioned, computers can only run on 1's and 0's for their switch operation. They completely do not understand code that's written by programmers. </p>
<p>However, computers <em>almost never</em> run the code you write directly. For example, if you write PHP, a common language on many web pages, it goes through <em>many</em> levels of translation. First, a server will take the PHP and &quot;interpret&quot; itâ€”basically converting it into something the server understands. For example, if you have a server written in C, the PHP would likely be interpreted by a C interpreter.</p>
<p>Now, with C, what do we do? A computer still can't run that. Instead, the C is then translated into something called Assembly, a language resembling a bit more of what the computer can natively handle. This is usually the job of a compiler [turning C into an executable], or the operating system through a similar process. </p>
<p>The Assembly is <em>still</em> a little bit too high-level for the computer to know what to do. It's processed by an <em>assembler</em> to convert it into machine code based on your CPU. Your CPU has certain &quot;instructions&quot; it knows what to do with, known as the <em>instruction set</em> (x86 and ARM being common in PC's with RISC-V and others being common in embedded chips). </p>
<p>Your CPU will then look at the machine code and it knows how to turn each of the instructions in machine code into actual binary and execute upon those. For example, machine code will frequently just involve binary math already such as adding 2 binary numbers, incrementing a binary number, etc... Thus, we've turned complex, human-readable PHP code into actual electricity flowing in your computer.</p>
<p>This is a gross simplification of the process though, and I know I'm skipping many nuances, especially since PHP in interpreted at runtime, instead of being a truly compiled language, yadda yadda, but the basic idea is the same.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Markaos" target="_blank">Markaos</a>
			<div class="markdown"><p>Depending on how much time you're willing to sink into understanding the interaction between software and hardware, you might want to check out Ben Eater's 8 bit computer build. He goes into detail on everything he does, so feel free to jump in at whatever is the first point you don't fully understand (or watch it all, his videos are great).</p>
<p><a href="https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU" target="_blank">https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU</a></p>
<p>If you have a good understanding of the &quot;basic&quot; circuits used in computers (logic gates, flip flops, latches...), you could skip all the way to the CPU control logic.</p>
<p>IIRC his videos go mostly from machine code down, so I will provide a bit more info towards the software side: step above the machine code is the assembly language - a program to add two numbers from addresses &quot;a1&quot; and &quot;a2&quot; and store the result in address &quot;a3&quot; in a typical assembly language (it is platform specific - x86 assembly is different from ARM assembly) might look like this:</p>
<pre><code>LOAD a1  ; load number from a1 into register
ADD a2   ; add number from a2 to whatever is currently in the register
STORE a3 ; save the current contents of the register (the result) to a3</code></pre>
<p>I think we can agree that this is 100% software side. In this language, you can write any program you want (including programs that take other languages and translate them to assembly or straight to machine code). The translation to the machine code is usually very simple, as the first word is just a mnemonic for certain <code>opcode</code> (just a number that the CPU uses to decide what to do; I won't go into detail on how opcodes are handled by the CPU as the linked videos explain it much better than I possibly could). For the sake of readability, let's say this is some CPU with 4 bit opcodes and 4 bit addresses, addresses a1 to a3 are (0000, 0001 and 0010) and opcodes for load, add and store are 0100, 0011 and 1100 respectively. In that case, the program would be translated like this:</p>
<pre><code>0100 0000
0011 0001
1100 0010</code></pre>
<p>All whitespace here is just formatting.</p>
<p>Again, how this series of 1s and 0s is handled by the CPU is a topic that's very well explained by the linked videos</p>
<p>Hope this helps you</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/glaba314" target="_blank">glaba314</a>
			<div class="markdown"><p>The base abstraction that hardware (CPUs) exposes to programmers is machine code, which is just very simple instructions in a row such as &quot;move data from here to there&quot;, &quot;add this to that&quot;, &quot;jump to a certain instruction if some condition is true&quot;, and so on. When it comes down to it, pretty much all computation can be done with just a couple of simple instructions like this (excluding the possibility of theoretical stuff like hypercomputation that most people are pretty sure doesn't physically exist, which is the Church-Turing Thesis, although there may be some funky stuff happening around rotating black holes that does actually allow it to be possible). Explaining how this actually works in hardware requires a lot of context that is difficult to explain in a Reddit comment, so I won't try. For the example you brought up of 3D graphics, it really does just boil down to doing a ton of simple mathematical operations, and typically the &quot;move data&quot; instruction I mentioned earlier is used to finally put it onto the screen, with a special portion of the computer memory reserved for visual output (yes I know this is a huge simplification for anyone who might be reading this). As for how programming languages get turned into these simple instructions, there are programs called &quot;compilers&quot; which are intended to do that. For a very simple example, the expression 2 * (3 + 5 / 2) could get turned into instructions: a = divide 5 by 2, b = add 3 to a, c = multiply 2 by b, where a, b, and c represent data locations in the computer (registers). You can imagine how we can use the &quot;jump&quot; instruction I mentioned earlier to create conditional logic (do A if something is true, and B if it's not) by computing a condition using arithmetic, and jumping to different instructions based on the resulting value. Similarly, we can also create looping logic (do something X times, or do something until condition C is true) pretty much the same way, by jumping back to an instruction we've already run and continuing from there. Compilers turn human readable language into machine code by following these principles (as well as doing a ton of optimizations on top of that to make it run faster).</p></div>		</li>
					</ul>
		</ul>
	