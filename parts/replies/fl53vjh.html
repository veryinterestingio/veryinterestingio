	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/El-Frantic" target="_blank">El-Frantic</a>
			<div class="markdown"><p>Reading this LI5: don't get it! Appreciate your explanation though, very thorough and understandable from my current age, so let me give it a go!</p>
<p>1 computer motor can't go faster. So they put in more motors so they can work more instead of making 1 faster now. </p>
<p>I could also say tl;dr. Does that about sum it up?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/handyjohnny" target="_blank">handyjohnny</a>
			<div class="markdown"><p>I need to move a 500 pound object. I can work out, get stronger, etc. and maybe I'll be able to move the object but it won't be easy and it won't move far. Conversely, me and my friends can move the object together. The more of us contributing, the easier it becomes for each of us.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/InterimFatGuy" target="_blank">InterimFatGuy</a>
			<div class="markdown"><p>Except you have to cut the object up into pieces and if two people try to pick up the same object everything goes to shit.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Nottherealeddy" target="_blank">Nottherealeddy</a>
			<div class="markdown"><p>More hands makes less work. Pitter patter.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/NotTheGreatPumpkin" target="_blank">NotTheGreatPumpkin</a>
			<div class="markdown"><p>A better analogy might be to imagine your parent/spouse/&quot;roommate&quot; just got back from the grocery store with a car full of groceries.  One person can train to get faster and faster at carrying groceries, but there's an upper, practical limit to how many bags of groceries one person can carry at time (16 bit processors vs 32 bit processors vs 64 bit processors) and how fast they can carry them (raw clock speed).  On the other hand, if more people in the house get off their butt and help then we get all groceries in the house at blinding speed.  I'm looking at you Brian.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/xix_xeaon" target="_blank">xix_xeaon</a>
			<div class="markdown"><p>This is right but there's a very important consideration left out. The work a &quot;computer motor&quot; does is essentially a very long list of super simple instructions: &quot;do this, do that, etc&quot;.</p>
<p>If the work is like a shopping list then you can have several &quot;motors&quot; each collecting one thing on the list at the same time. But if the work is more like assembling a piece of flat-pack furniture then all the steps have to be done in sequence and getting more &quot;motors&quot; doesn't really help you.</p>
<p>The problem is that most work is sequential and that's why we've tried so hard for so long to make a single motor faster, but we kind of can't anymore. Today software designers often have to spend a lot of time designing their software so that as many things as possible can be run in parallel so that they can make use of multiple cores because that's the only way to make it faster.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/El-Frantic" target="_blank">El-Frantic</a>
			<div class="markdown"><p>So the motors need a manager or work divider to indicate what can be done when?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/JimmyLightnin" target="_blank">JimmyLightnin</a>
			<div class="markdown"><p>As I was reading it, I was thinking more along the lines of adding extra lanes on the highway to increase traffic flow, rather than increasing the speed limit.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/questfor17" target="_blank">questfor17</a>
			<div class="markdown"><p>Causality arrow points the other way.  Because they stopped increasing single-CPU performance and began increasing core-count we've had to get better at using all those cores.</p>
<p>If the double the clock rate, your software runs 2x faster.  If they double the core count most software stacks need a lot of work to eventually run 2x faster.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Delioth" target="_blank">Delioth</a>
			<div class="markdown"><p>Well, they stopped increasing single-CPU performance because physics starts saying &quot;no&quot; at pretty close to where our top-end is at.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ChrisFromIT" target="_blank">ChrisFromIT</a>
			<div class="markdown"><p>It isn't quite right. When it comes to clock speed you are right. But there are other ways to increase single core performance. Like increase the amount of instructions per clock(IPC) that can be done, hardware acceleration of certain algorithms, lowering the latency of cache lookups, etc.</p>
<p>The issue is that most of those things require a lot of money for research and development, while adding more cores is an extremely cheap to do compared to the rest.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Job_Precipitation" target="_blank">Job_Precipitation</a>
			<div class="markdown"><p>I heard they had an overclocked pentium 4 going near 10 gigahertz a while back.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/MedusasSexyLegHair" target="_blank">MedusasSexyLegHair</a>
			<div class="markdown"><blockquote>
<p>If the double the clock rate, your software runs 2x faster.</p>
</blockquote>
<p>Not most software.  Most software is limited by IO, whether involving a drive, the network, or user input.  While it's true that you <em>can</em> write software that does heavy data processing and utilizes a lot of CPU, a modern CPU under typical workload running about 100 typical processes is likely only utilizing around 10-20% of its capacity.</p>
<p>That's another reason there hasn't been much need to speed up the CPUs.  The speed they run at now is already plenty fast for office work, web browsing, streaming media, playing videogames, etc.  Having multiple cores allows more processes to run at once, which is more typical of what people do - browsing in one window while a chat program in another is sending and receiving messages, while playing media is playing in a third and a download is in progress in a fourth, or whatever.  Few people are running highly-detailed weather simulations, scientific processing of large amounts of data, or otherwise straining their CPUs.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ThePantsThief" target="_blank">ThePantsThief</a>
			<div class="markdown"><p>I think you're being a little pedantic</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/4onen" target="_blank">4onen</a>
			<div class="markdown"><p>If a manufacturer doubles the core count of a processor line, all other factors being equal, no program will ever reach 2x performance on the new processors compared to the old.</p>
<p>I don't mean <em>almost</em> no programs. I mean <em>no</em> programs. Even if they're not cache or I/O bound, fully compute bound, absolutely embarrassingly parallel zero post-launch synchronization stuff, will not <em>reach</em> the 2x performance marker on double the number of cores.</p>
<p>Why? It's called &quot;Amdahl's Law.&quot; When they double the core count, parallel parts of the program can now have twice as many cores, so they'll run twice as fast. But the sequential part of the program, the part that has to exist at the beginning to launch the other processes? That will never get faster with more cores. In fact, launching <em>more</em> other threads may make that sequential part <em>slower</em>. But even assuming a computer where that's not the case, even assuming <em>infinite</em> cores, the program has only a finite speedup.</p>
<p>Having said all that, 1.5x is a reasonable speedup to see for a naiively parallel program given twice the cores. And 1.9x is a good figure after some optimizations to further decrease synchronization.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Nancy_Bluerain" target="_blank">Nancy_Bluerain</a>
			<div class="markdown"><p>Just wanted add a bit of extra to this: improvements in instruction sets.</p>
<p>It essentially means making the cpu smarter instead of faster.</p>
<p>Example: we have two students. They are both given the same calculation to solve: 10x2.</p>
<p>Student A is very fast when it comes to count, but not very smart. Student B is slow to count, but has knowledge Student A doesn’t have: the results of many basic calculations.</p>
<p>Student A doesn’t know how much 10x2 is. They need to do the math from scratch. They go 2+2+2+2+2+2+2+2+2+2. They need to make 10 operations to get to the result. Eventually the student will solve it and come up with 20, but this takes time and requires more energy to do so.</p>
<p>Student B however, already knows the result. They have an instruction set, in the form of the multiplication table, that they can use to give the result in a single operation. Student B doesn’t need to to add 2 together ten times. Student B knows that 10x2 = 20.</p>
<p>While student B is slower than Student A, Student A is still doing the math, when Student B has already solved it.</p>
<p>Yes, it’s very inaccurate, but for the sake of ELI5, it’s good enough, I think.</p>
<p>So, a smarter cpu with low core clock but an advanced instruction set may do certain tasks much faster than a “dumb” cpu with high core clock which does not have that same instruction set. That being said, if that cpu is given a task that is not in its instruction set, it may struggle.</p>
<p>This is the case with conventional desktop CPUs and ARM processors, too. There are many things an ARM can do way faster than a kick ass desktop CPU, also conserving power while doing so, but if we give them both a task that is not in the instruction set of the ARM processor, the Desktop cpu will of course wipe the floor with that ARM processor.</p>
<p>So there really are two things that makes CPUs appear faster while either keeping or lowering the core clock speed. Sharing the load among multiple cores, and making those cores smarter.</p></div>		</li>
					</ul>
	