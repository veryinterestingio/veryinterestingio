	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/strudelkopf" target="_blank">strudelkopf</a>
			<div class="markdown"><p>What did the tools of the developers look like? Did they program on a machine with a similar architecture? Also I can't imagine how you'd structure and test huge games like the first Pokémon rpgs. Asset handling, the development of the engine, etc. It must have been a huge pain compared to nowadays</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DarkAlman" target="_blank">DarkAlman</a>
			<div class="markdown"><p>Development was done on a computer</p>
<p>There were special sets of 'developer hardware' for the NES that you could buy that would allow you to push the code to NES hardware without have to make a ROM and cartridge for testing everytime you compiled code</p>
<p><a href="http://nintendoagemedia.com/users/8123/photobucket/812E27DF-B37B-1A7A-F9452A309E371CFB.png" target="_blank">http://nintendoagemedia.com/users/8123/photobucket/812E27DF-B37B-1A7A-F9452A309E371CFB.png</a></p>
<p><a href="http://nintendoagemedia.com/users/8123/photobucket/81340741-D085-F68A-EC83C04A85C79512.png" target="_blank">http://nintendoagemedia.com/users/8123/photobucket/81340741-D085-F68A-EC83C04A85C79512.png</a></p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/deus_mortuus_est" target="_blank">deus_mortuus_est</a>
			<div class="markdown"><p>Probably a lot like programmers of today's Arduino and similar devices, where you write the code, push it to the machine (I'm assuming the developers would have access to a development board of the NES), and test it there. As for writing, there probably weren't any IDE's, so they'd likely use vi/emacs.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/NewFolgers" target="_blank">NewFolgers</a>
			<div class="markdown"><p>vi/emacs was primarily a Unix culture thing (and surely popular on some other particular platforms as well - but sometimes not at all). Those are currently more popular outside of Unix/Linux than ever, but it wasn't always that way. On other platforms (e.g. even MSDOS - vi/emacs were far from normal.. and Japan was going their own way using whatever they were using), people used whatever text editors and/or IDE's were available. It wasn't necessarily elegant, but some editors had their own unique conveniences.</p>
<p>Personally, I wrote some pure assembler graphics apps using DOS Edit on MSDOS (although this was years after the NES's heyday). It wasn't pretty, but I didn't know any better. My development practice was to make it exit the program and spit out an error message and dump at the first sign of anything unexpected (basically assertions to verify my assumptions all over). I talked to plenty of other people writing assembly code, and never heard mention of vi or Emacs being used to develop for MSDOS (main PC operating system of the time). I expect that some professionals would have had a stepping debugger (communicating with some 6502 dev box via some protocol).. and that probably some wouldn't have too.</p>
<p>Also, I recall seeing a clip of people developing a Megaman game on TV once (whether this was an actual official Megaman game, or just someone writing a clone for fun, I do not know) - just for a few seconds, but I took great interest. It was happening on a PC screen, and I could see an artist placing the tiles with a large version of a sprite or two on the side. That was in the early to mid-90's probably.. which was a bit too late for it to make much sense.. but, maybe the footage just wasn't very up to date. It was touted as being actual pro development.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Streakdreniline" target="_blank">Streakdreniline</a>
			<div class="markdown"><p>So basically, the programming was basically physical, in a sense? I thought they worked with data you’d see in, say data registries, with the 0A, 1A, and so on.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/plaid_rabbit" target="_blank">plaid_rabbit</a>
			<div class="markdown"><p>I’d expect that they developed on one computer and the compiled the code to a eprom to test it. </p>
<p>I know with several of the middle generations of consoles, there were cards that plugged into a normal computer that let you do development.  Some of them plugged into a special console, or contained all the parts internally for a console.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mlpr34clopper" target="_blank">mlpr34clopper</a>
			<div class="markdown"><p>Even for first gen consoles. Google &quot;atari 2600 frobco&quot; -- They made a development system that conected a card in your apple ii+ or //e to your 2600 cartridge slot via ribbon cable. You wrote and assembled the code on the apple and it would load it into the board which the cartridge slot just saw as a normal cart.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/qqkiu" target="_blank">qqkiu</a>
			<div class="markdown"><p>When I started learning Forth, around 1988, some sources mentioned that several Atari games were developed in this language.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mlpr34clopper" target="_blank">mlpr34clopper</a>
			<div class="markdown"><p>I find that hard to believe as forth is an interpreted language, so any game you made would also have to have a forth inerpreter on the cartridge to run it. And 2600 carts had like only 4 like addressable adress space. I suppose its possible if they did bank switching, but still. Way more trouble than it would be worth.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/qqkiu" target="_blank">qqkiu</a>
			<div class="markdown"><p>I still have a Forth compiler for MSDOS. There were compilers and interpreters for Forth, just like BASIC . Forth was created to control telescopes exactly because it’s extremely compact, the code generated was smaller than almost any other language, although really hard to program.</p>
<p>Have fun : <a href="https://www.thefreecountry.com/compilers/forth.shtml" target="_blank">https://www.thefreecountry.com/compilers/forth.shtml</a></p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Plaidomatic" target="_blank">Plaidomatic</a>
			<div class="markdown"><p>Forth is also compilable. I learned Forth on a compiling interpreter. You did your editing/test/debug cycle in interpreter, and compiled directly in the interpreter. There were also linker options that were external, but you could compile simple code directly in the interpreter.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ZylonBane" target="_blank">ZylonBane</a>
			<div class="markdown"><p>They're talking about Atari computer games, not Atari console games.</p>
<p><a href="https://atariage.com/forums/topic/155951-games-written-in-forth/" target="_blank"><a href="https://atariage.com/forums/topic/155951-games-written-in-forth/" target="_blank">https://atariage.com/forums/topic/155951-games-written-in-forth/</a></a></p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/daveinsurgent" target="_blank">daveinsurgent</a>
			<div class="markdown"><p>Damn, so people have been arguing over abstraction vs. raw speed for like, ever then.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/fizzlefist" target="_blank">fizzlefist</a>
			<div class="markdown"><p>Well back then it made much more of a noticable difference. The 6502 and its contemporary processors were so simple by today's standards, and their coupled hardware (RAM, sound and video chips) equally limited, that every cycle mattered for smooth gameplay.</p></div>		</li>
					</ul>
		</ul>
	