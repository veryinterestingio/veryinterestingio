	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ShevekUrrasti" target="_blank">ShevekUrrasti</a>
			<div class="markdown"><p>And even if the most incredible kind of improvement to computers happen and they are able to do one operation every few Plank times (\~10^(-43)s), counting to 1 googol will take 10^(57)s, approximately 10^(49)years, still much much more than the age of the universe.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/acosmichippo" target="_blank">acosmichippo</a>
			<div class="markdown"><p>also, what about memory?  holding a number that large in memory would probably be tough too.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Pluto258" target="_blank">Pluto258</a>
			<div class="markdown"><p>Actually not bad at all.  Each bit of memory can hold a 0 or a 1 (one bit), so n bits of memory can hold 2^(n) possible values.  1 googol is 10^(100), so we would need log2(10^(100))=100log2(10)=333 bits (rounded up).</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/joe0400" target="_blank">joe0400</a>
			<div class="markdown"><p>around 333 bits. We can calculate this using log</p>
<pre><code>ceil(log(10^100)/log(2))) = 333 bits</code></pre></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/grenadesonfire2" target="_blank">grenadesonfire2</a>
			<div class="markdown"><p>Not really, a long (8 bytez) can hold max 1.8e19. With only about 40 bytes youd have 5 longs and could hold the number.</p>
<p>Now if we lock it down to java you have native support for big integer and then you wouldnt need to do anything special, just add one as you count in an insane for loop.</p>
<p>Edit: I have been informed I cant read. Will recalculate for the correct number later.</p>
<p>Edit2: i was thinking of longs as two ints (which is 4 bytes anyways) and wrote 2 bytes incorrectly.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DTMan101" target="_blank">DTMan101</a>
			<div class="markdown"><p>Would it be possible to run a cluster and further reduce the time?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/garblednonsense" target="_blank">garblednonsense</a>
			<div class="markdown"><p>If you have 10 devices in the cluster, that divides the answer by 10, so that's 10^48 rather than 10^49 years. And if you have 10000000000 devices, you're down to 10^39 years. It's really hard (impossibly hard!) to get that number down to something that's in range.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/No-Corgi" target="_blank">No-Corgi</a>
			<div class="markdown"><p>We've got 10^(100) years until the heat death of the universe, so no rush at all! 10^(100) is a googol, so as long as your computer can count once per year, you're okay. There are approx 5.8*10^(150) Planck times till the end, so we're still not going to make a googolplex unfortunately, even with the fastest computer possible.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CatalyticDragon" target="_blank">CatalyticDragon</a>
			<div class="markdown"><p>A single thread on a single CPU doesn't sound like the best way to go.</p>
<p>A top of the line super computer today has 2 million+ cores. If you partition segments off to each they can all count in parallel and you've just got a 2,000,000x speed up. </p>
<p>You could then also get all the thousands of super computers in the world to do their own bit. You could also ask each of the 2.71 billion mobile phones to join in. And the billion PCs. The half billion consoles. Even the 50 million smart TVs.</p>
<p>The big processing happens in the 500 'hyperscale' data centers around the globe though. That's at <em>least</em>  40,000,000 more cores we can add to the mix.</p>
<p>Assuming 1 Ghz and 1 instruction/cycle on average we're looking at 8.14×10\^18 operations a second which gets us all the way down to a still unfathomable 3.89×10\^73 years :)</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/_PM_ME_PANGOLINS_" target="_blank">_PM_ME_PANGOLINS_</a>
			<div class="markdown"><p>What does counting in parallel mean?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Zoenboen" target="_blank">Zoenboen</a>
			<div class="markdown"><p>People are giving you answers but forgetting counting is a serial activity. They aren't wrong, but they aren't at all correct either.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/[deleted]" target="_blank">[deleted]</a>
			<div class="markdown"><p>[entfernt]</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Themperror" target="_blank">Themperror</a>
			<div class="markdown"><p>lets say you have a set of 100 elements, andnyou want to count them to be sure its actually a 100 and not 99 or 101, you then divide that set over a N number of counters, lets say 5, now each counter gets roughly 100/5 = 20 elements, they all count 20 except one which did 19, now its 20*4 +19 = 99</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/gsdev" target="_blank">gsdev</a>
			<div class="markdown"><p>Can it really be considering &quot;counting&quot; if we can't guarantee that the numbers appear in the correct order?</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/TheBestLightsaber" target="_blank">TheBestLightsaber</a>
			<div class="markdown"><p>So what your saying is, the thing that'll unify the races of the galaxy is combining all processing power to count to 1 googolplex before the end of the universe. A true utopia</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CatalyticDragon" target="_blank">CatalyticDragon</a>
			<div class="markdown"><p>No I don't think I said that exactly. I said with a little bit of thinking we could shave off a very large amount of time from the calculation. And that's using technology we can imagine today which is obviously nothing like the technology of a century from now. If somebody said in 1,000 years we'd have computers many trillions of times more powerful than today's data centers orbiting the sun to directly convert its energy into processing I wouldn't dismiss it.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Cruuncher" target="_blank">Cruuncher</a>
			<div class="markdown"><p>Also, since it needs to hold integers bigger than you can fit into a 64 bit register it would take more than 1 cycle per add</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/xieta" target="_blank">xieta</a>
			<div class="markdown"><p>You would need 333 bits, any idea how many cycles?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AtLeastItsNotCancer" target="_blank">AtLeastItsNotCancer</a>
			<div class="markdown"><p>If you specifically designed a circuit for adding large numbers, say 512 bits in a single instruction, then you could do it in one cycle.</p>
<p>Otherwise you'd need to split it into 6 64-bit chunks. AFAIK modern cpus typically have an add with carry instruction, so you could do each increment in 6 instructions, so a minimum of 6 cycles.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CrockettScience" target="_blank">CrockettScience</a>
			<div class="markdown"><p>Oh no, it's way worse than that. That's how many bits it takes to represent a googol, 10^100. This is a googolplex, which is 10^googol. Since 10^googol = 2^n, solving for n  gives you 10^100 * log (10), base 2 of course.</p>
<p>So it takes about 3.3 times as many binary digits to represent a googolplex as it does <strong>decimal digits</strong>, of which it's already known there aren't even enough <strong>physical matter in the observable universe</strong> to build</p></div>		</li>
					</ul>
		</ul>
		</ul>
	