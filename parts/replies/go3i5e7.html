	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/domanite" target="_blank">domanite</a>
			<div class="markdown"><p>I was also going to present the 'language' analogy. Another perspective:</p>
<p>If you understand English, you can listen to it pretty fast. But if you have to simultaneously translate from English to Russian, its very difficult to maintain that same speed. When one computer architecture emulates a different one, it essentially has to translate from one language to another, in real time.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Yithar" target="_blank">Yithar</a>
			<div class="markdown"><blockquote>
<p>But if you have to simultaneously translate from English to Russian, its very difficult to maintain that same speed.  </p>
</blockquote>
<p>This is why I have a lot of respect for any translator that can do on the fly translation.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Anonymous7056" target="_blank">Anonymous7056</a>
			<div class="markdown"><p>That's the difference between being a translator, who has more time, and an interpreter.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Phantom160" target="_blank">Phantom160</a>
			<div class="markdown"><p>I’m fluent in two languages, but I’m really bad at translating in real time. I’ve been asked before “how hard can it be if you speak both languages” and the answer is “try listening to a song in your language, except you have to come up with a synonym for each word on the fly”. It still requires a lot of processing power even if you understand perfectly both the original word and the synonym.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/nighthawk_something" target="_blank">nighthawk_something</a>
			<div class="markdown"><p>There's a reason they have grey hair.</p>
<p>I had a teaher who wanted to be an interpreter. They became a teacher when they realized they were going to spend a few decades in a cubicle translating documents before doing anything real time</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/libgeek" target="_blank">libgeek</a>
			<div class="markdown"><p>Also, as I understand it, some processors have words that don't exist for other processors, so rather than translating puerta to door, you need to translate it to &quot;a rectangular piece of wood hanging on hinges along one vertical side that blocks a similarly sized hole in a wall&quot;.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Sanglyon" target="_blank">Sanglyon</a>
			<div class="markdown"><p>&quot;-And at that moment, I felt coming over me l'esprit de l'escalier</p>
<p>-What? Does not compute! Error! Error!&quot;</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/RamBamTyfus" target="_blank">RamBamTyfus</a>
			<div class="markdown"><p>Yes. And to add, some microcontrollers have features others don't have. And in the case of a game console, they often work together with other chips that are specifically made to do some special thing, such as making noises or drawing characters on the screen.<br />
While you can &quot;translate&quot; a program for another platforms, these differences make it a very hard task. It could take a year and then you still have only translated a single game. It is much more worthwhile to emulate the whole game console using software so you can run ALL games intended for it. The emulator translates all instructions on the fly and this causes it to run a little slower.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AgreeableLandscape3" target="_blank">AgreeableLandscape3</a>
			<div class="markdown"><p>Some very simple processors can't even multiply. They use loops that repeatedly adds numbers.</p>
<p>There's a good chance that the micro controller in your keyboard or mouse is one of those.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Pestilence86" target="_blank">Pestilence86</a>
			<div class="markdown"><p>Why can't it translate the whole program/game once and take as much time as it wants to do this, then read the translation?</p>
<p>EDIT: Wow thanks for the many comments. I read them all.</p>
<p>So i understand now that there are technical challenges, but also copyright challenges. It might be illegal to copy e.g. an old NES game, translate it to something modern computers understand, and distribute that.</p>
<p>This does probably have an impact on how much resources someone is willing to put into doing the permanent translation.</p>
<p>From this i take, that the original copyright holder of a game would be able to spend resources to do the translation and redistribute it. If the holder knows that the game is very popular, and that players would pay again to play the game on a modern system, then that might be an option.</p>
<p>I know too little about video game history to see if this was done before. But i would guess it was.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/domanite" target="_blank">domanite</a>
			<div class="markdown"><p>You can absolutely do this, it's just not what a program emulator typically does.</p>
<p>The technical reasons why you might want to pursue that route, or not, (or some possible middle ground) fall a little outside of ELI5-land.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/r40k" target="_blank">r40k</a>
			<div class="markdown"><p>Emulation doesn't make any changes to the data, it just changes how that data is read. In the case of N64 games, for example, all the games are ripped directly off the cartridges with no modification done afterwards. Instead, the emulator &quot;translates&quot; all the functions that an N64 would perform into functions that your x86 computer with your modern CPU and GPU and various related libraries can perform.</p>
<p>The equivalent to translating it all one time would be just rewriting and compiling the game to run &quot;natively&quot; without the need of an emulator and that requires reverse engineering or source code which typically nobody except the original developer has.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/aaaaaaaarrrrrgh" target="_blank">aaaaaaaarrrrrgh</a>
			<div class="markdown"><p>The machine code can contain instructions like &quot;next, execute the instruction number &lt;see memory cell 1&gt;&quot;</p>
<p>You don't know what will be in memory cell 1 at the time this instruction is executed, and so you don't know which instruction to execute next. And because some instructions that are a single instruction in one &quot;language&quot; have to be translated into multiple instructions, the numbers get all messed up. So at the very least, you'd have to maintain a table of where to jump, and every such jump would need to be translated into &quot;look into the table, then jump&quot;.</p>
<p>There are other gotchas. I would expect that some systems try this approach, others do just-in-time translation and then store the result so they don't have to do it over and over for the static parts while they can still handle stuff like this, etc.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/d2factotum" target="_blank">d2factotum</a>
			<div class="markdown"><p>It's not just the processor--the other hardware in the system (e.g. the graphics and sound hardware) will have to be emulated as well, which is a slow process compared to running natively. The rule of thumb I've heard is that a computer needs to be around 10-15x more powerful than whatever you're trying to emulate in order to compensate for this emulation overhead.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Tupcek" target="_blank">Tupcek</a>
			<div class="markdown"><p>that 10-15x is probably worst case scenario. ARM Macs can run some x86 software faster with emulation than last gen Macbooks natively. And they are not 10-15 times faster</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Snajpi" target="_blank">Snajpi</a>
			<div class="markdown"><p>I know this is hard to believe but &quot;the graphics and sound hardware&quot; have their own Processors, OP didn't say CPU, just a processor since it applies to them all...</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/frollard" target="_blank">frollard</a>
			<div class="markdown"><p>Addendum to \^ as it's excellent to begin with. It basically speaks to standardization. Every design choice has pros and cons, speed versus performance versus cost to implement. Different companies will take different approaches. In the world there are a few different widths and design of the tracks on railways. The cars for one set of tracks are almost universally unable to mount other tracks. A japanese bullet train won't run on north american freight tracks, and likewise, a freight train would have a hard time balancing on the mag-lev bullet train tracks. One is designed for throughput, other is designed for instantaneous speed.  This again speaks to a lot of decisions in chip architecture. Does it have lots of data carrying capacity/bandwidth, or does it make up for that buy running the lanes it has faster at higher cost to install. You can transport the same stuff the same distance but it will take different code to say 'load lots of game on a freight train at once' versus 'load a bit of the game on a bullet train and send it off many times'</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Mr_Greavous" target="_blank">Mr_Greavous</a>
			<div class="markdown"><p>will we ever have a uniform way of coding? like time, dates, etc are standard world wide.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/psycotica0" target="_blank">psycotica0</a>
			<div class="markdown"><p>There are many &quot;standards&quot;, but functionally no. But that's because the instruction set and hardware devices are directly tied to the operations the system is capable of, and the strengths the system brings to its tasks.</p>
<p>As soon as there was anything we wanted a machine to do that it didn't do before, the standard would have to be thrown out to account for this new capability.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/computergeek125" target="_blank">computergeek125</a>
			<div class="markdown"><p>Other commenter is quite correct, and I shall add: <a href="https://xkcd.com/927/" target="_blank">https://xkcd.com/927/</a></p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/bartbartholomew" target="_blank">bartbartholomew</a>
			<div class="markdown"><blockquote>
<p>time, dates, etc are standard world wide.</p>
</blockquote>
<p>Oh god I wish.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/zortlord" target="_blank">zortlord</a>
			<div class="markdown"><p>This is the correct answer. It's not just the instruction set that's different- it's the hardware activated by the instruction set. And different hardware choices are made based on design purposes of the entire computer.  </p>
<p>For example, most instruction sets include a load instruction to place a numerical value into a CPU register.  Something like-  </p>
<p>LD $4 1234</p>
<p>This is actually shorthand for a bunch of binary. In this case, &quot;LD&quot; is the OP code telling the processor what hardware components to activate, &quot;$4&quot; is the register in the CPU that the value should be stored, and &quot;1234&quot; is the number being loaded.  </p>
<p>But, if instruction set sizes are limited to 32 bits then the loaded number is limited in size for this instruction; it could only be a large as the bits not taken up by the OP code and register address. Additional instructions would be needed to load larger numbers. </p>
<p>A different processor could have a designated loading register that is assumed to always be used when loading values. That would reduce the instruction set to  </p>
<p>LD 1234  </p>
<p>This would leave more bits for the actual number but require additional instructions to move the value to another register.  This approach could be faster in some cases of number processing. </p>
<p>When emulating hardware, these different engineering tradeoffs must be detected and properly simulated.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/theScrapBook" target="_blank">theScrapBook</a>
			<div class="markdown"><p>Japanese bullet trains are hardly maglev (maglev trains haven't really been deployed on long distance tracks), but point taken.</p></div>		</li>
					</ul>
		</ul>
	