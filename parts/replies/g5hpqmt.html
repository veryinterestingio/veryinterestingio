	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DietDrDoomsdayPreppr" target="_blank">DietDrDoomsdayPreppr</a>
			<div class="markdown"><blockquote>
<p>imagine that you know how to add 2 numbers.</p>
</blockquote>
<p>Whoa there, buddy. Let's not get ahead of ourselves.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Racsoth" target="_blank">Racsoth</a>
			<div class="markdown"><p>This is ELI5, and 5 year old children usually have a lot of imagination, so I decided to go wild with my example.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/MyHairItches" target="_blank">MyHairItches</a>
			<div class="markdown"><p>I am still confused.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ravenQ" target="_blank">ravenQ</a>
			<div class="markdown"><p>Well Imagine you can add two one digit numbers.</p>
<p>Given that you can add large numbers by going digit after digit, adding and carrying a number to the higher order. This way you only need three two digit additions for each digit of a large number (one addition and one carry addition, and addition of two carries)</p>
<p>You can deal with addition of two one digit numbers by using a lookup table of size 100 (0+0, 1+0, 2+0 ,..., 5+4, 5+5,5+6..,9+9)</p>
<p>This way you have addition.</p>
<p>(Binary numbers are used instead in reality, single addition is actually addition of 3 bits (two bits and one carry), output being two bits, and this is in the ALU of CPU done with using AND,OR,XOR gates logic, and those are physically constructed using transistors and resistors, transistors are electronic devices(semiconductors) that can open and close current flow through wire using voltage/current on/through a third wire, which is basically an electonic switch, this effect is based on diode effect when two various metals form a charged layer on the boundary, that allows single direction current flow, this effect comes out of quantum effects of metal lattice, where atoms with orbitals with extra electrons and metal atoms that have missing electron in an orbital these electrons tend to wonder to the other metal, creating a charge</p>
<p>But this all given we understand quantum effects that lead to such a thing as orbital and existence of electromagnetism, electron probabilistic field and such</p>
<p>)</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/p_ke" target="_blank">p_ke</a>
			<div class="markdown"><p>Good one XD</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SeventeenHydralisks" target="_blank">SeventeenHydralisks</a>
			<div class="markdown"><p>You say that, but funnily enough, computers don't even know how to add 2 numbers. They 'decompose' the task of addition into a series of binary digit comparisons using <a href="https://en.wikipedia.org/wiki/Adder_\(electronics\)" target="_blank">adder cirtuits</a>.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/obsessedcrf" target="_blank">obsessedcrf</a>
			<div class="markdown"><p>That's really no different from how humans add numbers that are too big to memorize</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Digital_001" target="_blank">Digital_001</a>
			<div class="markdown"><p>That's usually built into the computer's instruction set though, so as a programmer you can say &quot;add two numbers&quot; in your program without breaking it up further, and the computer will do it for you. Some computers also have built-in instructions for multiplication and division to make them even faster.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DATY4944" target="_blank">DATY4944</a>
			<div class="markdown"><p>So...</p>
<p>Could you optimize a computer by letting it save the answers in memory?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ram_tya7" target="_blank">ram_tya7</a>
			<div class="markdown"><p>Lol, good one.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Sir_Oblong" target="_blank">Sir_Oblong</a>
			<div class="markdown"><p>Not that it really matters, but it's my understanding that when you do exponents, it doesn't actually do repeated multiplication, but instead does something a bit more clever. Still boils down to a sort of repeated multiplication though. But in the new way (I believe) it brings the complexity from O( 2^n ) to what you might imagine, O( n^3 ). Once again, doesn't really change anything about what you said, I just think it's neat.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/PunctuationsOptional" target="_blank">PunctuationsOptional</a>
			<div class="markdown"><p>I wish I understood.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Sir_Oblong" target="_blank">Sir_Oblong</a>
			<div class="markdown"><p>Basically, computers can add numbers together REALLY fast. They can multiply numbers together pretty fast (as it's essentially just repeated addition). But if you do exponents as repeated multiplication, turns out that, if the numbers get big enough, that's not terribly efficient. So instead, some clever people took advantage of the way that computers store numbers, and figured that, with a bit of tweaking, you could do exponents &quot;quickly&quot;. Suffice to say, &quot;classical&quot; exponentiation is actually quite inefficient.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/pazz199" target="_blank">pazz199</a>
			<div class="markdown"><p>The commenter used the so called &quot;Big O notation&quot; which basically states how complex a certain algorithm or process is, how many things it has to do. &quot;n&quot; in this case means the amount of stuff it has to process (in other words, the size of the input set).
O(1) means that <em>no matter how much it has to process</em>, it'll always take the same amount of work, whether it's getting 2 things or 200 things to process. </p>
<p>Now if you see <em>O(n)</em>, it means so called &quot;linear&quot; complexity. Basically each additional thing makes it do exactly the same amount of additional work. If you give it 1 thing, it has to do 1 amount of work, if you give it 30, it does 30. </p>
<p>O(n^2 ) means it ends up doing the <em>square</em> amount of work for each thing you give it. Give it 1 thing, it has to do 1 work, give it 2 things, it has to do 4 work, 3 makes it do 9, etc. </p>
<p>Of course this is a massive simplification, and I myself haven't delved too deep into it - so take it with a grain of salt and do your own research in case you care enough.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Neospector" target="_blank">Neospector</a>
			<div class="markdown"><p>&quot;Time complexity&quot; is a general way of saying how long something takes if you don't know how much data you're running through. O(2^n ) means it would take 2^n number of steps in the worst case scenario, where n is equal to the amount of data you have. O(n^3 ) means it would take n^3 in the worst case, again n is the amount of data you're working with.</p>
<p>In this case, computers use a trick called &quot;<a href="https://cp-algorithms.com/algebra/binary-exp.html" target="_blank">exponentiation by squaring</a>&quot; to reduce the amount of time it takes to do the operation, which is actually reducing it from (from what I can tell) O(n) linear time to O(log n) logarithmic time, which is more than twice as fast.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SinglePartyLeader" target="_blank">SinglePartyLeader</a>
			<div class="markdown"><p>Exponents are typically computed using <a href="https://en.m.wikipedia.org/wiki/Exponentiation_by_squaring" target="_blank">Fast exponentiation</a>, which is effectively using multiplication in an optimal way. Since x^n * x^n = x^(2n), we can speed up getting x^64 to just 6 operations instead of the full 64. It reduces the complexity down from O(n) to O(logn)</p>
<p>Ex: x^10 -&gt; x^(2^2^2)*x^2</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Sir_Oblong" target="_blank">Sir_Oblong</a>
			<div class="markdown"><p>Yes! Thanks for this! I didn't know all the details precisely, but yeah, the gist is that there's a more efficient way to exponentiation than just repeated multiplication.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/WorldsBegin" target="_blank">WorldsBegin</a>
			<div class="markdown"><p>&quot;Optimal&quot; might claim too much. What is being solved for for fast exponentiation is called an <a href="https://en.m.wikipedia.org/wiki/Addition_chain" target="_blank">Addition chain</a>. Exponentiation by squaring uses a specific, easy to compute chain for each exponent, but the chain is provably non-optimal. In practice it doesn't really matter, since computing a better chain is expensive, computing an optimal one is very expensive. The point of me geeking out is that if you know the exponent in advance, you can often times do better.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DarFtr" target="_blank">DarFtr</a>
			<div class="markdown"><p>The cool part is that because computers store the exponent in binary, calculating how to compose the square of square etc. Is ridiculously fast and only needs some shifting and or operations</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/immibis" target="_blank">immibis</a>
			<div class="markdown"><p>Exponents will be calculated using square-and-multiply, and multiplies will be calculated using double-and-add. Basically the way we calculate multiplications by hand (but in binary) instead of just adding over and over.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mfb-" target="_blank">mfb-</a>
			<div class="markdown"><p>It depends. Obviously non-integer exponents can't be calculated at all with that approach. You take the logarithm of the base, multiply that by the exponent, and then take the exponential. For integer exponents both approaches are possible, it depends on the implementation.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/immibis" target="_blank">immibis</a>
			<div class="markdown"><blockquote>
<p>Computers are machines that perform simple operations VERY fast.</p>
</blockquote>
<p>In other words, they are high-speed idiots.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/dalr3th1n" target="_blank">dalr3th1n</a>
			<div class="markdown"><p>They are, with one additional caveat.  They are <em>extremely</em> good at following incredibly precise instructions.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/atkinson137" target="_blank">atkinson137</a>
			<div class="markdown"><p>I'd argue they <em>only</em> follow instructions.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/immibis" target="_blank">immibis</a>
			<div class="markdown"><p>Of course. They're too stupid to do anything without precise instructions.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Mobius572" target="_blank">Mobius572</a>
			<div class="markdown"><p>So they're autistic?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/____gray_________" target="_blank">____gray_________</a>
			<div class="markdown"><p>This is the best description for computers aka thinking sand</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SaberToothGerbil" target="_blank">SaberToothGerbil</a>
			<div class="markdown"><p>We figured out how to force lightning through sand and make it show us cat videos.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/handyjuanito" target="_blank">handyjuanito</a>
			<div class="markdown"><p>TIL I'm a computer</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Gamerred101" target="_blank">Gamerred101</a>
			<div class="markdown"><p>No no no no, you're a <em>low speed</em> idiot</p></div>		</li>
					</ul>
		</ul>
		</ul>
	