	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Psyk60" target="_blank">Psyk60</a>
			<div class="markdown"><blockquote>
<p>And for the few applications that need larger numbers than that, there are mathematical tricks to calculate with larger numbers even on 64-bit systems. You lose some efficiency, but considering how rare these applications are, it's nowhere near worth changing to 128-bit for just that.</p>
</blockquote>
<p>To add to that, modern CPUs have instructions that can do up to 512-bit calculations, even though the CPU is fundamentally only 64-bit. So if you need to do calculations with numbers larger than 64 bits and performance is a concern, you can use those.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/fireattack" target="_blank">fireattack</a>
			<div class="markdown"><p>I get that 128bit is very unnecessary, but what stops us to use something like.. 66bit?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/pdpi" target="_blank">pdpi</a>
			<div class="markdown"><p>A good reason is that 66 bits is not a whole number of bytes. It's not impossible to design a CPU around it, but it's horrendously inconvenient.</p>
<p>Also, producing CPUs with a new word size is expensive, and you need to get software updated to take advantage of it. It's just a hassle and you need to get some meaningful payoff from it.</p>
<p>For most application, 64 bit numbers don't matter in the slightest. What's <em>really</em> important is jumping from 32-bit pointers capable of addressing 4GB of RAM to 64 bit pointers capable of addressing just plain unspeakable amounts of RAM. It'll probably be decades before we reach the limits of 64 bit in that regard, so bumping the word size to 66 bits would be a whole lot of hassle for no benefits whatsoever.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ThatOtherGuy_CA" target="_blank">ThatOtherGuy_CA</a>
			<div class="markdown"><p>So you could technically jump to 72?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AfterShave997" target="_blank">AfterShave997</a>
			<div class="markdown"><p>Bit sizes that are powers of 2 make things neat and tidy due to the binary nature of electronics. 64 is 2 to the power of 6, while 66 isn't a power of 2 at all.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/nomnomnomnomRABIES" target="_blank">nomnomnomnomRABIES</a>
			<div class="markdown"><blockquote>
<p>And for the few applications that need larger numbers than that, there are mathematical tricks to calculate with larger numbers even on 64-bit systems.</p>
</blockquote>
<p>Wasn't the same true from 32-bit to 64-bit on home computers?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/gerwen" target="_blank">gerwen</a>
			<div class="markdown"><p>Yes, however the jump from 32-bit to 64-bit on home computers was more about being able to address larger amounts of RAM.  32-bit computers were limited to about 4GB of RAM.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/nomnomnomnomRABIES" target="_blank">nomnomnomnomRABIES</a>
			<div class="markdown"><p>But 32-bit Ubuntu can have 64gb ram</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/squigs" target="_blank">squigs</a>
			<div class="markdown"><p>Yes. Even on an 8 bit CPU, a 64 bit operation isn't horribly complicated. You just need to do the calculation in segments. </p>
<p>Compilers will do this automatically (at least up to 32 bits).</p></div>		</li>
					</ul>
		</ul>
	