	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/wes00mertes" target="_blank">wes00mertes</a>
			<div class="markdown"><p>One of my favorite fun facts about one of my favorite video games of all time:</p>
<p>Despite the existence of these higher level languages, Roller Coaster Tycoon creator Chris Sawyer wrote 99% of the game in assembly. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/spigotface" target="_blank">spigotface</a>
			<div class="markdown"><p>That’s also one of the reasons that it can run at 1,000,000 fps even on a potato. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/The_F_B_I" target="_blank">The_F_B_I</a>
			<div class="markdown"><p>Well, most home computers were potatoes back when that game came out. A lot of people were still rocking OG Pentiums and Pentium 2's</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/marsten" target="_blank">marsten</a>
			<div class="markdown"><p>Back in the Vic 20/Commodore 64 days a lot of people didn't even have proper assemblers, which will do thing like resolve memory addresses. They would hand-assemble code directly into hex opcodes. Quite a few of the cartridge games from that era (Gridrunner for example) have longish runs of hex code 'EA' in a memory dump, the significance of which is that EA is the opcode for the NOP (no operation) CPU instruction. The NOPs served as padding so that if a subroutine had to be lengthened a bit, the programmer wouldn't have to re-hand-assemble all of the code that followed (memory references in particular were a pain). As a kid I learned assembly by looking through a lot of code with a monitor, and these long strings of NOPs were a dead giveaway that the programmer was doing things by hand.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/grunt_monkey_" target="_blank">grunt_monkey_</a>
			<div class="markdown"><p>Is that the origin of the name of the company EA games?</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/UglyNeckBeard" target="_blank">UglyNeckBeard</a>
			<div class="markdown"><blockquote>
<p>first person to write a compiler was actually a woman, Grace Hopper</p>
</blockquote>
<p>Grace Hopper coined the term &quot;compiler&quot; but she only wrote a &quot;linker&quot; (albeit an important component of a full compiler). The first compiler was written by Corrado Böhm, in 1951, for his PhD thesis.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/1wd" target="_blank">1wd</a>
			<div class="markdown"><blockquote>
<p>The first compiler was written by Corrado Böhm, in 1951, for his PhD thesis.</p>
</blockquote>
<p><a href="http://www.itu.dk/people/sestoft/boehmthesis/boehm.pdf" target="_blank">English translation</a>. Chapter 7 contains the compiler. It targets a hypothetical computer with positive integers of 14 decimal digits.
The source language consists of expressions using:</p>
<p>Operations:</p>
<ul>
<li><code>+</code> (Addition)</li>
<li><code>∸</code> (Difference if positive, else 0)</li>
<li><code>·</code>  (Product)</li>
<li><code>:</code> (Integer division)</li>
<li><code>÷</code> (Absolute difference)</li>
<li><code>mod</code> (Remainder)</li>
<li><code>∪</code> (Maximum)</li>
<li><code>∩</code> (Minimum)</li>
<li><code>→</code> (Assignment)</li>
</ul>
<p>(The target computer has three-address code instructions for these operations.)</p>
<p>Variables:</p>
<ul>
<li><code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code> (Single letter variables only)</li>
<li><code>↓a</code>-<code>↓z</code>, <code>↓A</code>-<code>↓Z</code> (Indirect address access, treated as single symbols)</li>
<li><code>π</code> (Program counter)</li>
<li><code>π'</code> (Program counter at start of subroutine)</li>
<li><code>Ω</code> (Address that always contains the number 0. 0 is the HALT instruction.)</li>
<li><code>?</code> (Input or output)</li>
</ul>
<p>Parentheses:</p>
<ul>
<li><code>(</code> and <code>)</code></li>
</ul></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SupremeDictatorPaul" target="_blank">SupremeDictatorPaul</a>
			<div class="markdown"><p>How would you handle branching (if/then) with this?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/coolkid1717" target="_blank">coolkid1717</a>
			<div class="markdown"><p>Highjacking for easy visibility. Here is a series on EXACTLY how an 8 bit computer works. All of it's parts, all of it's chips, all of it's programming by hand, and all built from scratch.</p>
<p>Building an 8-bit breadboard computer!: <a href="https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU" target="_blank">https://www.youtube.com/playlist?list=PLowKtXNTBypGqImE405J2565dvjafglHU</a></p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/bpooqd" target="_blank">bpooqd</a>
			<div class="markdown"><p>Its a fantastic series, I'm still in the process of building one following his instructions, don't really have to be an electrical engineer to do that he explains it really well for anyone.</p>
<p>The best part of it all is that it doesn't require any soldering, which was always the number one hurdle for me.</p>
<p>I'm a software engineer but only really using high level languages so I never fully got to understand how it works on the bare metal, this is a great way to learn it.</p>
<p>He published the parts list here: <a href="https://eater.net/8bit/parts" target="_blank"><a href="https://eater.net/8bit/parts" target="_blank">https://eater.net/8bit/parts</a></a> (I can recommend <a href="https://www.mouser.com" target="_blank"><a href="https://www.mouser.com" target="_blank">https://www.mouser.com</a></a> to order, they are great and had almost all of the parts in stock)</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/TimmTuesday" target="_blank">TimmTuesday</a>
			<div class="markdown"><p>Very cool. Thanks</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/thehackeysack01" target="_blank">thehackeysack01</a>
			<div class="markdown"><p>if you don't want to actually breadboard, but want to start with NAND gates and build a working 16 bit machine:</p>
<p><a href="https://www.nand2tetris.org/" target="_blank">https://www.nand2tetris.org/</a></p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/PantsuitNixon" target="_blank">PantsuitNixon</a>
			<div class="markdown"><p>And she also coined the phrase &quot;computer bug.&quot;</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/thisischemistry" target="_blank">thisischemistry</a>
			<div class="markdown"><p>Kind of. A &quot;bug&quot; was already well-known in technical circles by that time, an early reference found was <a href="https://www.computerworld.com/article/2515435/app-development/moth-in-the-machine--debugging-the-origins-of--bug-.html" target="_blank">by Thomas Edison</a></p>
<p>Grace Hopper <a href="https://www.computerhistory.org/tdih/september/9/" target="_blank">recorded a funny instance</a> of finding an actual bug that caused a computer &quot;bug&quot;. She didn't find the moth that caused it, she was simply the one who wrote it in the logbook.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DivineBeastVahHelsin" target="_blank">DivineBeastVahHelsin</a>
			<div class="markdown"><p>Slightly off topic but may be mildly interesting: people still code in assembly even to this day for small low-power processors such as DSPs where every clock cycle counts. It’s getting less and less common as C compilers are more efficiently targeted to these custom devices, but it still happens in a lot of places. </p>
<p>Of course, it’s not exactly the same process as the early days. Instead of memorising / looking up the sequence of 1s and 0s for “store number 1 in register r2” you write a statement such as “str 1, r2” and the toolchain translates that to the appropriate binary. It’s like an intermediate layer between the machine code and the higher level code. And you get a pretty-ish IDE running on your desktop rather than using punchcards. But overall you still have to have an in-depth knowledge of the underlying processor hardware and its capabilities, and the patience of a saint :) for what it’s worth, some people really enjoy it. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/OfFiveNine" target="_blank">OfFiveNine</a>
			<div class="markdown"><p>Interesting side-note though: Some early card-punching machines didn't actually require you to memorize the 0's and 1's. They were more like a typewriter where you could press something that had a meaning, and that would punch the instruction/value into the card. I guess you could call that a very low-level type of assembly compilation... albeit physically implemented.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/tatanka01" target="_blank">tatanka01</a>
			<div class="markdown"><p>I've programmed in Fortran using keypunch cards (college, mid-70's).  Each card was a line of Fortran code.  Or assembly code, or whatever.  The punch card was simply a means to get the data into the computer's memory (whatever that data might be).  </p>
<p>Keypunch machines really were quite simple.  Typewriter like keyboard like you said and if you typed &quot;A&quot; it would punch the pattern for an &quot;A&quot; on the card in some ASCII-like code.  Each card would hold 80 (I think?) characters (think bytes).  The cards themselves could probably be thought of as a primitive form of storage.  </p>
<p>The keypunch machines weren't connected to the computer.  Instead, after you typed your program into a &quot;deck of cards,&quot; you'd submit the cards to a computer operator.  The operator would run them through a card reader which was the actual input device on the computer.  If you made an error in a line of code, you'd retype that one card and replace it in the deck and resubmit it for another run.  All output was on 11x17 &quot;bluebar&quot; tractor-fed paper which came off a high-speed line printer that used actual ink ribbons.  </p>
<p>Computer of course was a mainframe like you'd see in a 1940's horror flick.</p>
<p>Fun stuff - haven't thought of this in awhile.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ExWRX" target="_blank">ExWRX</a>
			<div class="markdown"><p>That just made what a compiler does click for me, thank you for that.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/tatanka01" target="_blank">tatanka01</a>
			<div class="markdown"><p>Technically, the 1's and 0's level is machine language.  Assembly language is the step above that -- mov ax, bx, etc. An Assembler converts the pseudo code into the 1's and 0's.  </p>
<p>It's very common (if not ubiquitous) for compilers to generate assembly language as an intermediate step.  You write something in C++, the compiler converts that into assembly and runs it through an assembler to generate the actual executable code.  Most compilers will have a switch to generate the intermediate assembly source code to a print file so you can see all that.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/DivineBeastVahHelsin" target="_blank">DivineBeastVahHelsin</a>
			<div class="markdown"><p>Yes absolutely right, thanks for the correction :)</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/miraculum_one" target="_blank">miraculum_one</a>
			<div class="markdown"><p>&quot;Who are you calling pseudo?&quot;
-- Assembly code</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/doublehyphen" target="_blank">doublehyphen</a>
			<div class="markdown"><p>JIT (just in time) compilers generally do not generate assembly because they tend to focus on compilation speed. But there are JIT compilers which even generate C code and compile it with an ordinary compiler which usually uses assembly as an intermediate step (Ruby MRI 2.6 for one).</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/jasonthomson" target="_blank">jasonthomson</a>
			<div class="markdown"><p>A couple of other examples I have encountered are the routines to read and write flash, and to receive/transmit data on a radio.</p>
<p>&#x200B;</p>
<p>Also, if you enjoy assembly at all, check out Human Resource Machine.  It's a game in which you're actually writing small assembly programs with a GUI.  There is a sequel, 7 Billion Humans, in which you control multiple people using a slightly higher level language. I played these on PC but they were designed to be mobile/tablet games.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/hugopeeters" target="_blank">hugopeeters</a>
			<div class="markdown"><p>Dude, look up Zachtronics. He is the maker of multiple great games with low-level programming mechanics. </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Terr_" target="_blank">Terr_</a>
			<div class="markdown"><p>I really tried to like HRM, but as the campaign goes on it feels more and more like an exercise in how much tedium you're willing to tolerate acting as your own compiler, as opposed to looking for clever solutions.</p>
<p>In contrast, Shenzhen IO has some similar quasi-assembly, but the challenges you face are a little more varied and colorful.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/livrem" target="_blank">livrem</a>
			<div class="markdown"><p>Oh, a sequel? Have to check that out. I enjoyed HRM and even my then 8yo played the first few levels without requiring too much assistance. Great intro to how computers work.</p></div>		</li>
					</ul>
		</ul>
		</ul>
	