	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/victorzamora" target="_blank">victorzamora</a>
			<div class="markdown"><p>This.  For a lot of reasons, accuracy matters a lot more than speed.  Plus, &quot;emulation&quot; isn't a port or a new version.  &quot;Emulation&quot; is, by definition, attempting to recreate the original hardware as accurately as possible.  Those accuracies include hardware limitations.</p>
<p>In the world of speedrunning, you actually EXPECT and DEPEND ON certain slowdowns in certain areas/rooms or under certain circumstances.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/[deleted]" target="_blank">[deleted]</a>
			<div class="markdown"><p>[gel√∂scht]</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/victorzamora" target="_blank">victorzamora</a>
			<div class="markdown"><p>That's a tough decision. From a purist perspective, you'd want it in hardware, of course. However, there's a big challenge in getting it to fail in just the right ways</p>
<p>In software, you could have an option to ignore it for now, and then maybe have a toggle once you get it sorted out. That way, purists can have the same performance and casuals can have a smoother experience.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ech0starr" target="_blank">ech0starr</a>
			<div class="markdown"><p>What do you mean exactly by &quot;Risks&quot;?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Furyful_Fawful" target="_blank">Furyful_Fawful</a>
			<div class="markdown"><p>The risk would be that buggy behavior breaks or crashes the game.  For example, if you program off the assumption that some data transfer takes X time to run, and it finishes before you're ready for it, you may not have actually finished preparing the data that got transferred.  Now you have garbage in the spot where you're transferring to, and that can cause all <em>sorts</em> of issues.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/xchaibard" target="_blank">xchaibard</a>
			<div class="markdown"><p>Race conditions. My favorite programming trope. Sometimes they were relied upon or even intentionally used on the original hardware.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/corgi92" target="_blank">corgi92</a>
			<div class="markdown"><p>Don't know about console games, but some of the older DOS games use a CPU's clock speed to measure how much time has passed. Running them on a modern CPU without underclocking it would result in the game running faster that intended. They may use the clock speed for any other metric, too, if they expect it to be a constant value.</p>
<p>Console games might have more examples like this because, when developers write a game for a certain console, they expect the clock speed to be a certain number so they feel safe using it as a constant value.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/HeippodeiPeippo" target="_blank">HeippodeiPeippo</a>
			<div class="markdown"><p>I got one example of using clock speed to count time... In the 90s i did a step sequencer to C64. It doesn't have any real time clock... It was simply a nightmare trying to make it steady, i had to count individual clock cycles on each block of code and invent &quot;filler code&quot; to fill out the time left between different scenarios (to be fair, i could control exceptions so there were only very few of them, in the &quot;run&quot; state it was one solid block of code with one interruption).. But i could never solve how the system itself handled all interruptions and how long it will take, i got most of them... The drift at the end was about 1:40, 1 second in 40 seconds... Games did very little to care about those things, they could drift a LOT more... so you could easily run game code at speed of &quot;it gets there when it gets there&quot;...</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Neoptolemus85" target="_blank">Neoptolemus85</a>
			<div class="markdown"><p>There's a great article here on why accuracy matters:</p>
<p><a href="https://arstechnica.com/gaming/2011/08/accuracy-takes-power-one-mans-3ghz-quest-to-build-a-perfect-snes-emulator/" target="_blank">https://arstechnica.com/gaming/2011/08/accuracy-takes-power-one-mans-3ghz-quest-to-build-a-perfect-snes-emulator/</a></p>
<p>In short, older consoles had a much less standardised way of drawing graphics to the screen. They didn't have APIs like DirectX, the whole hardware was open to them.</p>
<p>Certain games could do weird things you dont expect, like messing with the memory or drawing elements during certain very precise stages of the CRT display cycle which, if not timed correctly (e.g. by letting the clock run faster than expected), could lead to graphical glitches or crashes.</p>
<p>In short, timing in many games is extremely important, and the sync is based on a very precise clock speed which cannot be messed with without problems arising.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Musaranho" target="_blank">Musaranho</a>
			<div class="markdown"><p>If I got this correctly, most of the problem goes back to the simulating specific hardware specs through software, especially because most older games were written in low-level languages, very close and very dependent of the hardware itself.</p>
<p>I just have some questions:</p>
<ul>
<li>Does that mean that developing emulators became &quot;easier&quot; as we moved to using high level programming languages, like Python, to write games?</li>
<li>Is that why older computer games tend to be easier to run in newer computer systems, cause they're already developed to run with many different hardware specs?</li>
<li>Is that why many PC ports of console games ended up with very weird bugs and performance issues (e.g. GTAIV), cause of game code running on hardware specs that differ from the original one and behaving in erratic ways?</li>
</ul></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Sw429" target="_blank">Sw429</a>
			<div class="markdown"><p>This is the correct answer. Not sure why there's an incorrect answer voted higher.</p></div>		</li>
					</ul>
	