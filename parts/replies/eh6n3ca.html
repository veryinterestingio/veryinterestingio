	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Owatch" target="_blank">Owatch</a>
			<div class="markdown"><p>I might add that modern CPUs do have 128 bit registers in their floating point units (and sometimes even 256), as that is an area where precision gains can be realized. It also doubles as a way to do SIMD operations on lower precision float formats. But then again that is separate from the width of the overall processor architecture.  </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/orangeman10987" target="_blank">orangeman10987</a>
			<div class="markdown"><p>For clarity to others who may not know computer architecture terms that well, SIMD is &quot;single instruction, multiple data&quot;, where the processor is designed in a way to make doing a single operation on many bits of data efficient. An example of this is GPUs. </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Nolzi" target="_blank">Nolzi</a>
			<div class="markdown"><p>Not just 256, recent intel processors has 512 bit SIMD: <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-512" target="_blank">https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX-512</a></p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/BCProgramming" target="_blank">BCProgramming</a>
			<div class="markdown"><p>Very common misconception.</p>
<p>The Data size processed by the CPU, the data size  that can be accepted by the CPU, and the size of the address Bus are independent. They aren't always the same, and in fact seldom are.</p>
<p>For example the 8088 was a 16-bit CPU. This means that when it ran instructions, the CPU itself processed 16-bits of data at a time in it's registers.</p>
<p>It's connection to memory was 8-bits; it required two memory operations to fill a 16-bit register. (This is in contrast to the 8086, which had a 16-bit data bus).</p>
<p>It was not limited to 256 bytes of RAM (2^8) or to 64K (2^16), because it's address bus was 20-bits, allowing for 1MB of Addressable Memory space.</p>
<p>This misconception largely springs from a licensing limitation that is imposed on consumer Windows releases; 32-bit Windows releases will limit the VMM to using a maximum of 4GB of Memory, so people presume that 2^32=4GB and that is why 32-bit CPUs cannot use more. But this isn't true- it's an intentional limitation. By way of example, Windows NT4 Enterprise, which ran on 32-bit CPUs, had a maximum memory of 8GB of RAM.</p>
<p>Modern processors have a 64-bit processor bus and data bus, (With some special-purpose processing ALUs that can handle larger registers for specific instructions) but typically have the same 48-bit Address bus as in most x86 32-bit processors, allowing for 256TB of total addressable memory.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/anttirt" target="_blank">anttirt</a>
			<div class="markdown"><p>I want to add that all mainstream 32-bit instruction sets have memory operation instructions that are limited to a 32-bit byte-addressed address space, and correspondingly programming languages that compile 32-bit code use 32-bit byte-addressed pointers, limiting the available space for standard language constructs to 4GB per process.</p>
<p>These 32-bit addresses are what application programmers actually see and interact with, and the actual width of the physical address bus is only relevant to the operating system and the hardware.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/bobert680" target="_blank">bobert680</a>
			<div class="markdown"><p>that was very informative. thank you</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Kered13" target="_blank">Kered13</a>
			<div class="markdown"><blockquote>
<p>This misconception largely springs from a licensing limitation that is imposed on consumer Windows releases; 32-bit Windows releases will limit the VMM to using a maximum of 4GB of Memory, so people presume that 232=4GB and that is why 32-bit CPUs cannot use more. But this isn't true- it's an intentional limitation. By way of example, Windows NT4 Enterprise, which ran on 32-bit CPUs, had a maximum memory of 8GB of RAM.</p>
</blockquote>
<p>Even without that limitation 32-bit x86 programs could only access 4 GB of memory, at least without ring 0 privileges, as that was the size of the virtual address space. Accessing more physical memory than that required mapping physical pages in and out of the virtual address space, which only the OS can do.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/cryo" target="_blank">cryo</a>
			<div class="markdown"><p>I might also add that modern CPUs only have a 48 bit memory bus, and this is taken advantage of in software (x86-64 and ARMv8).</p></div>		</li>
					</ul>
	