<li class="post" data-handle="dj1i9k">
	<div class="overview">
		<a class="source" href="https://www.reddit.com/r/askscience/comments/dj1i9k/how_can_software_perform_tasks_hardware_cantt/" target="_blank" title="Reddit thread where this comes from"><i class="fa fa-external-link" aria-hidden="true"></i></a>
		<h2>
			<span class="tags tag-Computing">Computing</span>
			<a href="/posts/dj1i9k" onclick="return false">How can software perform tasks hardware cant’t?</a>
		</h2>
		<!--<span class="date">2019-10-20</span>-->
		<span class="is-new">NEW</span>
	</div>

		<div class="question"><span class="qa" title="Question">Q:</span><div class="markdown"><p>I was watching a lecture about assemblers/compilers and the lecturer at MIT indicated “what we’d like to do is build a general purpose processor that can run programs written in many high level languages [c, Python, Java]. Not only that but we want to be able to not make the hardware overly complex and support every feature in our high level language.”</p>
<p>How can the high level language provide functionality that doesn’t exist in the hardware in <em>some</em> fashion? I’ve heard this before, that we want to separate software implementation and hardware implementation (or something to that effect), which I can’t understand - somewhere someway there must be hardware doing what this language supports via the assembler/compiler/translator.</p>
<p>The only thing I can think of is she’s being imprecise and what she means is that the hardware can support all these high level language features, just not intrinsically - There is no machine instruction an assembler can invoke to make something eg “volatile” as in the c++ library, but it can build something equivalent from simple instructions that make up a RISC processor? That I can understand.</p>
<p><a href="https://youtu.be/d-roh8Vsb2M" target="_blank">Relevant lecture</a>, in the beginning.</p></div></div>

	<div class="comment-section">
		<div class="answers-placeholder">
			<div class="answers">
	<div class="answer" data-handle="f40jnom">
		<a class="author" href="https://www.reddit.com/user/UnicycleBloke" target="_blank">UnicycleBloke</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Any computation can be broken into simple steps. Maybe trillions of them, but all simple. The hardware only needs to be capable of the simple operations. The compiler translates high level operations into simple ones. Hardware can of course add features such as multipliers, say, to perform some complex operations faster. </p>
<p>Volatile is a good example: it's a purely compile time construct. The hardware neither knows nor cares when or whether you access variables or memory mapped registers. It has no idea what variables even are. But the compiler does care, and emits assembler which achieves the desired result.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="f40iaci">
		<a class="author" href="https://www.reddit.com/user/Dr_Hanza" target="_blank">Dr_Hanza</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Software emulation </p>
<p>If your cpu can do basic mathematical operations then some sequence and combination of those operations would eventually be able to do every computing operation provided it has enough memory. </p>
<p>For example if your cpu can add but can't multiply in hardware then you can write it in the software such as adding the number of times it needs to be multiplied. E.g 2x5 = 2+2+2+2+2</p>
<p>Practically you'd want a cpu that is fast enough to emulate the operations in reasonable amount of time.</p>
<p>In terms of hardware there is nothing stopping you to say run simulations of galactic collision on your home PC processor but the time it'd take to do it would likely be beyond your lifetime. Nevertheless it's possible with emulation as long as all computation can be broken down to basic mathematical operations (with conditionals and other logic ofc).</p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="f40kitc">
		<a class="author" href="https://www.reddit.com/user/tulipoika" target="_blank">tulipoika</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Theoretically if you have a “processor” that can perform NAND operations on single bits you could use it to run anything in the world. Slowly, but still. You wouldn’t still call it a processor that can, for example, perform Fourier transforms or ray tracing, because it doesn’t have any operations that do those, but you still can program it to do such things. </p>
<p>I assume what they meant was what you also deduced: the processor would have support for specific high level things directly, not split into smaller pieces.</p>
<p>I personally don’t know why we would want a processor that runs C because it’s meant to be compiled anyway. Java bytecode is another thing but since it’s deliberately unoptimized again a compilation step from bytecode to native is in order. And Python again having unlimited number ranges and whatnots...</p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="f40sm9f">
		<a class="author" href="https://www.reddit.com/user/Peter5930" target="_blank">Peter5930</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Building a basic computer is easy, people do it in Minecraft all the time.  Building a modern computer is very hard and Minecraft definitely can't be used to emulate it.  What's the difference if they're both computers?  The basic computer only runs basic operations like add, subtract and bitshift, but the modern i9-based turbo edition gigacomputer has huge tracts of silicon given over to circuits dedicated to specific functions like calculating the square roots of numbers or performing various exotic technical operations simultaneously across large chunks of data (SIMD extensions for accelerating video decoding, encryption that sort of thing), and although the basic computer can do those same things if you write enough software to reproduce those functions, it will be painfully slow and will take it hundreds or thousands of operations to calculate what can be done in a quick instant by running some electricity through some logic gates that are already set up to give the correct answer in a single seamless operation.</p>
<p>So adding instructions lets you do complex things in less time, but instructions aren't free, they're actual physical circuits fabricated into the CPU that take up space and draw power and produce heat.  So you want enough instructions so that your cpu is fast for the things most people want to use it for, but you don't want unnecessary instructions that will rarely be used because that's silicon real-estate and power draw being wasted.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="f40ni1g">
		<a class="author" href="https://www.reddit.com/user/SamQuan236" target="_blank">SamQuan236</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>the relevant concept here is a turing machine. basically, and as other commenters have pointed out, is that your can break any computable problem into a series of tiny steps. if you have a hardware device that can read a mark, move to a new position using that mark, and write new marks, you have the core ingredients for a Turing machine.</p>
<p>this means that even a simple computer, with adequate storage and time, and importantly, the right software, can solve nearly any problem. (though you can't tell if the computation will finish in fine time). </p>
<p>hardware, however needs to be configured to do exactly what needs to be done at large. if your have a cpu instruction that can add integers, then that's all it vac do without software. if however you wanted to multiply, then your could emulate this in software as a bunch of repeated additions.</p>
<p>edit: fix autocorrect</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
</div>		</div>
		<div class="more-less">
			<a class="collapse" href="javascript:void(0)">collapse</a>
			<a class="more-answers" href="javascript:void(0)">4 more answers...</a>
			<a class="less-answers lower" href="javascript:void(0)">less answers...</a>
			&nbsp;
		</div>
	</div>
	<a class="show" href="/posts/dj1i9k" onclick="return false"><span>show</span></a>
</li>
